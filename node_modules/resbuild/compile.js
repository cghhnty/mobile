var fs = require('fs');
var path = require('path');
var crypto = require('crypto');
var zlib = require('zlib');
var conf = require('./conf');

module.exports = compile;

function compile(src, dest, opts, cb) {
	if (!opts) {
		opts = {};
	} else if (opts.constructor == Function) {
		cb = opts;
		opts = {};
	}

	if (!cb)
		cb = function() {};

	if (opts.compress == undefined)
		opts.compress = true;

	if (!opts.gzipTypes)
		opts.gzipTypes = ['html', 'css', 'js'];

	try {
		var files = fs.readdirSync(src);
	} catch (e) {
		console.error(e);
		return cb(e);
	}

	try {
		fs.mkdirSync(dest);
	} catch (e) {}

	var i = -1;
	var loop = function() {
		if (++i >= files.length)
			return cb();

		var filename = files[i];
		var extname = path.extname(filename).slice(1);

		var input = src + '/' + filename;
		var stats = fs.statSync(input);

		if (stats.isFile()) {
			if (extname == 'map')
				return loop();

			var _files = [input];
		} else if (stats.isDirectory()) {
			if (conf.compiler[extname]) {
				_files = fs.readdirSync(input).map(function(file) {
					return input + '/' + file;
				});
			} else {
				return compile(input, dest + '/' + filename, opts, function(err) {
					if (err)
						return cb(err);

					loop();
				});
			}
		} else {
			return loop();
		}

		if (conf.compiler[extname]) {
			var compiler = require('./' + extname);
			var outputExt = conf.compiler[extname];
			var output = dest + '/' + filename.slice(0, -extname.length) + outputExt;
		} else {
			compiler = require('./concat');
			outputExt = extname;
			output = dest + '/' + filename;
		}

		var sourceRoot = path.relative(dest, '.').split('\\').join('/');

		try {
			var oldMeta = JSON.parse(fs.readFileSync(output + '.meta', 'utf8'));
		} catch (e) {}

		var meta = {
			source: input
		};

		if (stats.isFile() && fs.existsSync(input + '.map')) {
			compileCallback(null, {
				data: fs.readFileSync(input),
				map: fs.readFileSync(input + '.map')
			});
		} else if (stats.isFile() && input.slice(-extname.length - 5, -extname.length - 1) == '.min') {
			compileCallback(null, {
				data: fs.readFileSync(input)
			});
		} else {
			compiler(_files, {
				filename: input,
				sourceRoot: sourceRoot,
				compress: opts.compress,
				srcModified: function() {
					var hash = crypto.createHash('md5');
					_files.map(function(file) {
						hash.update(file, 'utf8');
						hash.update(fs.readFileSync(file));
					});
					meta.srcChecksum = hash.digest('hex');

					return !oldMeta || oldMeta.srcChecksum != meta.srcChecksum;
				}
			}, compileCallback);
		}

		function compileCallback(err, result) {
			if (err) {
				console.log('compile: ' + input);
				console.error(err);
				return cb(err);
			}

			if (!result)
				return loop();

			meta.checksum = crypto.createHash('md5').update(result.data).digest('hex');

			if (!oldMeta || oldMeta.checksum != meta.checksum || oldMeta.source != meta.source || oldMeta.srcChecksum != meta.srcChecksum) {
				console.log('compile: ' + input);

				fs.writeFileSync(output, result.data);
				result.map && fs.writeFileSync(output + '.map', result.map);
				fs.writeFileSync(output + '.meta', JSON.stringify(meta));

				if (opts.gzipTypes.indexOf(outputExt) == -1) {
					loop();
				} else {
					zlib.gzip(result.data, function(err, buf) {
						fs.writeFileSync(output + '.gz', buf);
						loop();
					});
				}
			} else {
				loop();
			}
		}
	};
	loop();
}
