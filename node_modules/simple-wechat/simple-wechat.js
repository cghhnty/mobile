var util = require('util');
var url = require('url');
var https = require('https');
var http = require('http');
var xml2js = require('xml2js');
var js2xmlparser= require('js2xmlparser');
var crypto = require('crypto');
var FormData = require('form-data');
var fs = require('fs');
var randchars = require('./randchars');

function jsonEscape(str) {
  return str.replace(/[\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, '');
}

function parseXml(xml, cb) {
  xml2js.parseString(xml, {
    explicitRoot: false,
    explicitArray: false
  }, cb);
}

// xml2js.Builder can not escape special characters (&<>" and emoji characters)
function buildXml(obj) {
  return js2xmlparser('xml', obj, {
    declaration: {
      include: false
    },
    useCDATA: true
  });
}

function capitalize(obj) {
  var result = new obj.constructor();

  if (obj.constructor == Object) {
    for (var p in obj) {
      var value = obj[p];
      if (value && value.constructor == Array)
        value = capitalize(value);
      result[p.charAt(0).toUpperCase() + p.slice(1)] = value;
    }
  } else if (obj.constructor == Array) {
    for (var i = 0; i < obj.length; i++) {
      var item = obj[i];
      if (item && item.constructor == Object)
        result.push(capitalize(item));
      else
        result.push(item);
    }
  } else {
    return obj;
  }

  return result;
}

var wechat = {};

wechat.Response = function(req, res, token, cb) {
  var me = this;
  me.req = req;
  me.res = res;
  me.token = token;
  me.cb = cb;
  var query = url.parse(req.url, true).query;

  if (req.method == 'GET') {
    res.end(me.checkSignature(query) ? query.echostr : '');
  } else {
    if (!me.checkSignature(query))
      return res.end();

    var body = '';
    req.on('data', function(chunk) {
      body += chunk;
    });
    req.on('end', function() {
      parseXml(body, function(err, msg) {
        me.message = msg;
        cb(null, msg, me);
      });
    });
  }
};

wechat.Response.prototype = {
  checkSignature: function(query) {
    var me = this;
    var signature = query.signature;
    var timestamp = query.timestamp;
    var nonce = query.nonce;
    var token = me.token;
    var arr = [token, timestamp, nonce];
    arr.sort();
    var str = arr.join('');
    var hash = crypto.createHash('sha1').update(str, 'utf8').digest('hex');
    return hash == signature;
  },

  reply: function(msg) {
    var me = this;
    msg = capitalize(msg);

    var formatedMsg;

    if (msg.constructor == String) {
      formatedMsg = {
        MsgType: 'text',
        Content: msg
      };
    } else if (msg.constructor == Array) {
      formatedMsg = {
        MsgType: 'news',
        ArticleCount: msg.length,
        Articles: {
          item: msg
        }
      };
    } else {
      if (msg.MediaId) {
        formatedMsg = {
          MsgType: msg.MsgType,
        };
        formatedMsg[msg.MsgType.charAt(0).toUpperCase() + msg.MsgType.slice(1)] = msg;
        delete msg.MsgType;
      } else {
        formatedMsg = msg;
      }
    }

    me.res.setHeader('Content-Type', 'text/xml');
    formatedMsg.ToUserName = me.message.FromUserName;
    formatedMsg.FromUserName = me.message.ToUserName;
    formatedMsg.CreateTime = (Date.now() / 1000).toFixed();
    var xml = buildXml(formatedMsg);
    me.res.end(xml);
  }
};

wechat.Api = function(appId, appSecret, store) {
  var me = this;
  me.appId = appId;
  me.appSecret = appSecret;
  me.store = store;
};

wechat.Api.prototype = {
  url: {
    base: 'https://api.weixin.qq.com',
    api: 'https://api.weixin.qq.com/cgi-bin',
    oauth: 'https://open.weixin.qq.com/connect/oauth2',
    media: 'http://file.api.weixin.qq.com/cgi-bin/media'
  },

  requestDefaults: {
    method: 'GET',
    type: 'json',
    query: null,
    requireAccessToken: true,
    base:  'https://yuujj/cgi-bin'
  },

  getAccessToken: function(cb) {
    var me = this;

    if (!cb)
      cb = function() {};

    var now = Date.now();
    if (me.accessToken && me.accessToken.expire > now) {
      cb(null, me.accessToken.token);

      // 提前1小时刷新accessToken. 这样在过期前1小时内只要有一个用户连接, 就能后台刷新accessToken, 不阻碍用户请求.
      if (me.accessToken.expire - 3600 * 1000 < now)
        me.refreshAccessToken();
    } else {
      me.store.get('accessToken', function(err, accessToken) {
        if (err)
          return cb(err);

        if (accessToken && accessToken.expire > now) {
          me.accessToken = accessToken;
          cb(null, me.accessToken.token);
          if (me.accessToken.expire - 3600 * 1000 < now)
            me.refreshAccessToken();
        } else {
          me.refreshAccessToken(cb);
        }
      });
    }
  },

  refreshAccessToken: function(cb) {
    var me = this;

    if (!cb)
      cb = function() {};

    me.store.lock('accessToken', function(err, result) {
      if (err)
        return cb(err);

      if (!result)
        return cb();

      me.request('token', {
        query: {
          grant_type: 'client_credential',
          appid: me.appId,
          secret: me.appSecret
        },
        requireAccessToken: false
      }, function(err, result) {
        if (err)
          return cb(err);

        me.accessToken = {
          token: result.access_token,
          expire: Date.now() + 7000 * 1000 // 过期时间提前200秒
        };
        me.store.set('accessToken', me.accessToken, 7000);
        cb(null, me.accessToken.token);
      });
    });
  },

  getJsApiTicket: function(cb) {
    var me = this;

    if (!cb)
      cb = function() {};

    var now = Date.now();
    if (me.jsapiTicket && me.jsapiTicket.expire > now) {
      cb(null, me.jsapiTicket.ticket);
      if (me.jsapiTicket.expire - 3600 * 1000 < now)
        me.refreshJsApiTicket();
    } else {
      me.store.get('jsapiTicket', function(err, jsapiTicket) {
        if (err)
          return cb(err);

        if (jsapiTicket && jsapiTicket.expire > now) {
          me.jsapiTicket = jsapiTicket;
          cb(null, me.jsapiTicket.ticket);
          if (me.jsapiTicket.expire - 3600 * 1000 < now)
            me.refreshJsApiTicket();
        } else {
          me.refreshJsApiTicket(cb);
        }
      });
    }
  },

  refreshJsApiTicket: function(cb) {
    var me = this;

    if (!cb)
      cb = function() {};

    me.store.lock('jsapiTicket', function(err, result) {
      if (err)
        return cb(err);

      if (!result)
        return cb();

      me.get('ticket/getticket', {type: 'jsapi'}, function(err, result) {
        if (err)
          return cb(err);

        me.jsapiTicket = {
          ticket: result.ticket,
          expire: Date.now() + 7000 * 1000 // 过期时间提前200秒
        };
        me.store.set('jsapiTicket', me.jsapiTicket, 7000);
        cb(null, me.jsapiTicket.ticket);
      });
    });
  },

  jsApiSign: function(url, cb) {
    var me = this;

    me.getJsApiTicket(function(err, ticket) {
      if (err)
        return cb(err);

      var sign = {
        appId: me.appId,
        timestamp: Math.round(Date.now() / 1000),
        nonceStr: randchars(16, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz')
      };

      var str = 'jsapi_ticket=' + ticket + '&noncestr=' + sign.nonceStr + '&timestamp=' + sign.timestamp + '&url=' + url;
      sign.signature = crypto.createHash('sha1').update(str, 'utf8').digest('hex');
      sign.jsapi_ticket = ticket;
      cb(null, sign);
    });
  },

  request: function(path, opts, cb) {
    var me = this;

    if (opts && opts.constructor == Function) {
      cb = opts;
      opts = null;
    }

    if (!opts)
      opts = {};

    if (!opts.method && opts.body)
      opts.method = 'POST';

    for (var p in me.requestDefaults) {
      if (opts[p] === undefined)
        opts[p] = me.requestDefaults[p];
    }

    if (opts.requireAccessToken) {
      me.getAccessToken(function(err, accessToken) {
        if (err)
          return cb(err);
        next(accessToken);
      });
    } else {
      next();
    }

    function next(accessToken) {
      var reqOpts = url.parse(opts.base + '/' + path, true);

      delete reqOpts.search;

      if (opts.requireAccessToken)
        reqOpts.query.access_token = accessToken;

      if (opts.query) {
        for (var p in opts.query)
          reqOpts.query[p] = opts.query[p];
      }

      reqOpts = url.parse(url.format(reqOpts));
      reqOpts.method = opts.method;
        reqOpts.headers = {};

        if (opts.body) {
            var body;
            if (opts.type == 'json') {
                body = JSON.stringify(opts.body);
                reqOpts.headers['Content-Length'] = Buffer.byteLength(body, 'utf8');
                reqOpts.headers['Content-Type'] = 'application/json';
            } else if (opts.type == 'xml') {
                body = buildXml(opts.body);
                reqOpts.headers['Content-Length'] = Buffer.byteLength(body, 'utf8');
                reqOpts.headers['Content-Type'] = 'application/xml';
            } else {
                body = opts.body;
                reqOpts.headers['Content-Length'] = Buffer.byteLength(body, 'utf8');
                reqOpts.headers['Content-Type'] = 'application/text';
            }


        }

      var req = https.request(reqOpts, function(res) {
        var body = new Buffer(0);

        res.on('data', function(chunk) {
          body = Buffer.concat([body, chunk]);
        });

        res.on('end', function() {
          body = body.toString();
          try {
            var result = JSON.parse(jsonEscape(body));
          } catch (e) {
            e.data = body;
            return cb(e);
          }

          if (result.errcode) {
            if (result.errcode == 40001 && path != 'token')
              me.refreshAccessToken();
            return cb(result);
          } else {
            return cb(null, result);
          }
        });
      });

      req.on('error', function(e) {
          error.log("simple-wechat/simple-wechat: request send to WeChat failure: "+e.stack);
         // console.log(e.stack);
        cb(e);
      });

        if (body) {
            req.write(body);
        }

      req.end();
    }
  },

  get: function(url, query, cb) {
    var me = this;

    if (query && query.constructor == Function) {
      cb = query;
      query = null;
    }

    return me.request(url, {method: 'GET', query: query}, cb);
  },

  post: function(url, body, cb) {
    var me = this;

    if (body && body.constructor == Function) {
      cb = body;
      body = null;
    }

    return me.request(url, {method: 'POST', body: body}, cb);
  },

  uploadMedia: function(data, type, cb) {
    var me = this;
    var form = new FormData();
    if (data.constructor == String) {
      if (/^https?:/.test(data)) {
        var _http = /^https:/.test(data) ? https : http;
        var req = _http.request(data, function(res) {
          form.append('media', res);
          submit();
        });

        req.on('error', function(err) {
          cb(err);
        });

        req.end();
      } else {
        form.append('media', fs.createReadStream(data));
        submit();
      }
    } else {
      form.append('media', data);
      submit();
    }

    function submit() {
      // 微信服务器bug: post body 最后必须有个空行, 否则无法解析最后一个form field
      // 我们随便塞一个field来解决这个问题.
      form.append('weixin sucks', 'aha');

      me.getAccessToken(function(err, accessToken) {
        if (err)
          return cb(err);

        form.submit(url.parse(me.url.media + '/upload?access_token=' + accessToken + '&type=' + type), function(err, res) {
          if (err)
            return cb(err);

          var body = new Buffer(0);

          res.on('data', function(chunk) {
            body = Buffer.concat([body, chunk]);
          });

          res.on('end', function() {
            body = body.toString();
            try {
              var result = JSON.parse(jsonEscape(body));
            } catch (e) {
              e.data = body;
              return cb(e);
            }

            if (result.errcode) {
              if (result.errcode == 40001)
                me.refreshAccessToken();
              return cb(result);
            } else {
              return cb(null, result);
            }
          });
        });
      });
    }
  },

  getMedia: function(mediaId, cb) {
    var me = this;
    me.getAccessToken(function(err, accessToken) {
      if (err)
        return cb(err);

      var mediaUrl = me.url.media + '/get?access_token=' + accessToken + '&media_id=' + mediaId;
      http.get(mediaUrl, function(res) {
        // 没有 content-disposition 头说明返回的是错误信息
        if (!res.headers['content-disposition']) {
          var body = new Buffer(0);

          res.on('data', function(chunk) {
            body = Buffer.concat([body, chunk]);
          });

          res.on('end', function() {
            body = body.toString();
            try {
              var result = JSON.parse(jsonEscape(body));
            } catch (e) {
              e.data = body;
              return cb(e);
            }

           return cb(body);
          });
        } else {
          return cb(null, res);
        }
      }).on('error', function(err) {
        cb(err);
      });
    });
  }
};

module.exports = wechat;
